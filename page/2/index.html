<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>及时当勉励，岁月不待人！@iNuo - 及时当勉励，岁月不待人！@iNuo</title>
    
    <meta name="description" content="">
    <meta name="author" content="">
    
    <link href="https://xshi000.github.io/an-old-hope.min.css" rel="stylesheet">
    <link href="https://xshi000.github.io/style.css" rel="stylesheet">
    <link href="https://xshi000.github.io/custom.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://xshi000.github.io/apple-touch-icon.png">
    <link rel="icon" href="https://xshi000.github.io/favicon.ico">
    <meta name="generator" content="Hugo 0.65.3" />
    
    <link rel="alternate" type="application/rss+xml" href="https://xshi000.github.io/index.xml" title="及时当勉励，岁月不待人！@iNuo" />
    
    
    <script>
      function setTheme() {
        const time = new Date();

        const prev = localStorage.getItem('date');
        const date = String(time.getMonth() + 1) + '.' + String(time.getDate());

        const now = time.getTime();
        let sunrise;
        let sunset;

        function setBodyClass() {
          if (now > sunrise && now < sunset) return;
          document.body.classList.add('dark');
        }

        if (date !== prev) {
          fetch('https://api.ipgeolocation.io/astronomy?apiKey=5ed37d85103e4defa5df4c5298ed5215')
            .then(res => res.json())
            .then(data => {
              sunrise = data.sunrise.split(':').map(Number);
              sunset = data.sunset.split(':').map(Number);
            })
            .catch(() => {
              sunrise = [7, 0];
              sunset = [19, 0];
            })
            .finally(() => {
              sunrise = time.setHours(sunrise[0], sunrise[1], 0);
              sunset = time.setHours(sunset[0], sunset[1], 0);
              setBodyClass();
              localStorage.setItem('sunrise', sunrise);
              localStorage.setItem('sunset', sunset);
            });
          localStorage.setItem('date', date);
        } else {
          sunrise = Number(localStorage.getItem('sunrise'));
          sunset = Number(localStorage.getItem('sunset'));
          setBodyClass();
        }
      }
    </script>
  </head>
  <body class="list home">
    <script>
      setTheme();
    </script>
    <header class="header">
      <nav class="nav">
        <h1 class="logo"><a href="https://xshi000.github.io/">及时当勉励，岁月不待人！@iNuo</a></h1>
      </nav>
    </header>
    <main class="main">

<header class="page-header"><h1>及时当勉励，岁月不待人！@iNuo</h1></header>

<article class="post-entry">
  <header class="entry-header">
    <h2>极简Java七：多线程与网络编程</h2>
  </header>
  <section class="entry-content">
   <p>第一章  本章内容  多线程 线程安全 线程状态   1.1 多线程 现在想要设计一个程序，边打游戏边听歌，怎么设计？
要解决上述问题,咱们得使用多进程或者多线程来解决.
并发与并行   并行：指两个或多个事件在同一时刻发生（同时发生）。
  并发：指两个或多个事件在同一个时间段内发生。
  线程与进程   进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。
  线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。
  简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程
我们可以在电脑底部任务栏，右键&gt;打开任务管理器,可以查看当前任务的进程：
进程
线程：
调度方式   分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。
  抢占式调度：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。
  其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。
主线程 回想我们以前学习中写过的代码，当我们在dos命令行中输入java空格类名回车后，启动JVM，并且加载对应的class文件。虚拟机并会从main方法开始执行我们的程序代码，一直把main方法的代码执行结束。如果在执行过程遇到循环时间比较长的代码，那么在循环之后的其他代码是不会被马上执行的。如下代码演示：
public class A_Thread { void show() { for (int i=1;i&lt;=10000 ;i&#43;&#43; ) { System.out.println(&#34;i=&#34;&#43;i); } } } public class A_MainThread { public static void main(String[] args) { A_Thread t=new A_Thread(); t....</p>
  </section>
  <footer class="entry-footer">
    <time>January 24, 2021</time>
  </footer>
  <a class="entry-link" href="https://xshi000.github.io/java_7/"></a>
</article>
<article class="post-entry">
  <header class="entry-header">
    <h2>极简Java六：反射注解</h2>
  </header>
  <section class="entry-content">
   <p>第一章  本章内容  反射   1.1 反射 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法！所以先要获取到每一个字节码文件对应的Class类型的对象。
Class类 获取Class对象的三种方式
 方式一: 通过Object类中的getObject()方法  Person p = new Person(); Class c = p.getClass();  方式二: 通过 类名.class 获取到字节码文件对象（任意数据类型都具备一个class静态属性,看上去要比第一种方式简单）。  Class c2 = Person.class;  方式三: 通过Class类中的方法（将类名作为字符串传递给Class类中的静态方法forName即可）。  Class c3 = Class.forName(&#34;Person&#34;); 注意：第三种和前两种的区别
 前两种你必须明确Person类型； 第三种是指定这种类型的字符串就行，这种扩展更强！我不需要知道你的类，我只提供字符串，按照配置文件加载就可以了  代码演示：
/* \ 获取.class字节码文件对象的方式 \ 1：通过Object类中的getObject()方法 \ 2: 通过 类名.class 获取到字节码文件对象 \ 3: 反射中的方法, \public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException \返回与带有给定字符串名的类或接口相关联的 Class 对象 */ public class ReflectDemoReflect { public static void main(String[] args) throws ClassNotFoundException { // 1： 通过Object类中的getObject()方法  // Person p1 = new Person();  // Class c1 = p1....</p>
  </section>
  <footer class="entry-footer">
    <time>January 23, 2021</time>
  </footer>
  <a class="entry-link" href="https://xshi000.github.io/java_6/"></a>
</article>
<article class="post-entry">
  <header class="entry-header">
    <h2>极简Java五：IO流</h2>
  </header>
  <section class="entry-content">
   <p>第一章  本章内容  递归 File类 FileInputStream FileOutputStream   1.1 递归 递归的概述 递归，指在当前方法内调用自己的这种现象！
public class DemoStack { public static void main(String[] args) { method(); } public static void method(){ System.out.println(&#34;递归的演示&#34;); //在当前方法内调用自己  method(); } }   递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。
  在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。
  public class DemoDigui { public static void main(String[] args) { test(1); } public static void test(int i){ System.out.println(i); if(i==10000){ return; } test(&#43;&#43;i); } } 递归的代码演示，计算1-n之间的和，使用递归完成...</p>
  </section>
  <footer class="entry-footer">
    <time>January 22, 2021</time>
  </footer>
  <a class="entry-link" href="https://xshi000.github.io/java_5/"></a>
</article>
<article class="post-entry">
  <header class="entry-header">
    <h2>极简Java四：集合框架</h2>
  </header>
  <section class="entry-content">
   <p>第一章  本章内容  集合接口介绍 集合遍历   集合概述 （1）集合是存储其他对象的特殊对象，可以将集合当做一个容器
（2）集合的相关接口和类位于java.util包中
（3）集合中的接口和类是一个整体、一个体系，整个体系称为集合框架
集合与数组的相同点和不同点：   数组的长度是固定的，集合的长度可以变化
  集合中存储的元素必须是引用类型数据
  1.1 集合接口介绍 集合框架定义了一些接口，它们决定了集合类的本质特性。具体的集合类只是提供了标准接口的不同实现。
Collection接口    方 法 描 述     * boolean add(E obj) 将obj添加到调用集合。   boolean addAll(Collection&lt;? extends E&gt; c) 将c中的所有元素添加到调用集合中。   * boolean remove(Object obj) 从调用集合中删除obj的一个实例。   boolean removeAll(Collection&lt;?&gt; c) 从调用集合中删除c的所有元素。   * void clear() 删除调用集合中的所有元素   * boolean contains(Object obj) 如果obj是调用集合的元素，则返回true。   * boolean isEmpty() 如果调用集合为空，则返回true。   * int size() 返回调用集合中元素的数量   * Iteratoriterator() 返回调用集合的一个迭代器   containAll(Collection c)     List接口 List（列表）：表示有序、元素可以重复的集合。...</p>
  </section>
  <footer class="entry-footer">
    <time>January 21, 2021</time>
  </footer>
  <a class="entry-link" href="https://xshi000.github.io/java_4/"></a>
</article>
<article class="post-entry">
  <header class="entry-header">
    <h2>极简Java三：Object类与常用API</h2>
  </header>
  <section class="entry-content">
   <p>第一章  本章内容  Object类   1.1 Object类概述 java.lang.Object类是Java语言中的根类，即所有类的父类。它的所有方法子类都可以使用。
如果一个类没有特别指定父类， 那么默认则继承自Object类。例如：
public class Person extends Object { ... } 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：
  public String toString()：返回该对象的字符串表示
  public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”
  toString方法 方法摘要  public String toString()：返回该对象的字符串表示。  toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型&#43;@&#43;内存地址值。
由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。
覆盖重写 如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：
public class Person { private String name; private int age; @Override public String toString() { return &#34;Person{&#34; &#43; &#34;name=&#39;&#34; &#43; name &#43; &#39;\&#39;&#39; &#43; &#34;, age=&#34; &#43; age &#43; &#39;}&#39;; } // 省略构造器与Getter Setter  } public class Test { public static void main(String[] args) { Person p=new Person(&#34;iNuo&#34;,23); //重写toString方法运行结果  System....</p>
  </section>
  <footer class="entry-footer">
    <time>January 20, 2021</time>
  </footer>
  <a class="entry-link" href="https://xshi000.github.io/java_3/"></a>
</article>
<article class="post-entry">
  <header class="entry-header">
    <h2>极简Java二：面对对象</h2>
  </header>
  <section class="entry-content">
   <p>第一章  本章内容  类和对象   理解什么是面向过程、面向对象 面向过程与面向对象都是我们编程中，编写程序的一种思维方式。
  面向过程的程序设计方式，是解决一个问题，先思考“我该怎么做”，然后一步步实现的过程。
  面向对象的程序设计方式，是解决一个问题先找出里面涉及的事物，然后通过事物之间的交互来完成。
面向对象思维方式是一种更符合人们思考习惯的思想
  例：买砖戒
对象在代码中的体现 描述小汽车。
分析：
事物的特点（属性）： 颜色。 轮胎个数。 事物的(功能)： 运行。 发现：事物其实就是由特点（属性）和行为（功能）组成的。
属性用变量表示，行为功能用方法表示
小汽车 { 颜色； 轮胎个数； 运行() { } } 通过计算机语言Java来描述这个事物。
 定义类的格式  public class 类名 { //可编写0至n个属性  数据类型 变量名1； 数据类型 变量名2； //可编写0至n个方法  修饰符 返回值类型 方法名(参数){ 执行语句; } }  汽车类  public class Car { String color; int number; void run() { System....</p>
  </section>
  <footer class="entry-footer">
    <time>January 17, 2021</time>
  </footer>
  <a class="entry-link" href="https://xshi000.github.io/java_2/"></a>
</article>
<article class="post-entry">
  <header class="entry-header">
    <h2>极简Java一：Java基础</h2>
  </header>
  <section class="entry-content">
   <p>第一章  本章内容：   Java技术体系
  二进制和十进制转换
  常用dos命令
  Java程序开发流程
  常用快捷键
  使用Api文档
  反编译工具
   1.1 Java的诞生与发展历史 Java是Sun于1995年推出的高级编程语言，2009年被oracle收购。
计算机语言就是能被计算机理解并执行的指令。
Java发展历史中的版本 1995年Sun公司发布Java1.0版本 1997年发布Java 1.1版本 1998年发布Java 1.2版本 2000年发布Java 1.3版本 2002年发布Java 1.4版本 2004年发布Java 1.5版本 2006年发布Java 1.6版本 2009年Oracle甲骨文公司收购Sun公司，并于2011发布Java 1.7版本 2014年发布Java 1.8版本 2017年发布Java 9.0版本
1.2 Java技术体系 Java技术分为三个体系：
  Java SE（J2SE - Platform Standard Edition，java平台标准版）它是学习Java EE的基础
  Java EE（J2EE - Java 2 Platform,Enterprise Edition，java平台企业版）开发面向Internet的应用程序 Java Web...</p>
  </section>
  <footer class="entry-footer">
    <time>December 19, 2020</time>
  </footer>
  <a class="entry-link" href="https://xshi000.github.io/java_1/"></a>
</article>
<article class="post-entry">
  <header class="entry-header">
    <h2>论文写作技巧</h2>
  </header>
  <section class="entry-content">
   <p>1.降重 代码降重    代码加注释
  批量改变量（Ctrl&#43;F 查找）改为全称/简称
  添加透明字符，普通字符变小变白
  代码变图片（需pdf软件转换）
   文本降重    文本添加到公式框内，即文字转变为图片
  算法流程转流程图，常用，降重并且简洁
   2.三线表？    去除所有格式，边框：无框线
  添加上下框线，较粗一点
  选定第一行，添加下框线，线条正常粗细
      字体格式问题：中文（宋体，小四） 英文&amp;数字（Time New Romance）
  表格公式占位宽问题：段落，取消勾选两个勾
  表名问题：表上图下（图不用带标题）字体小一号；表标题上一行文字，进入段落，设置段后（0.5行）
  表标题：加粗，大小与正文一致
  打印与预览 可看最终效果！
   3.公式上浮？  对于段落中的公式上浮问题：...</p>
  </section>
  <footer class="entry-footer">
    <time>September 29, 2020</time>
  </footer>
  <a class="entry-link" href="https://xshi000.github.io/write/"></a>
</article>
<article class="post-entry">
  <header class="entry-header">
    <h2>DBSCAN聚类算法流程图</h2>
  </header>
  <section class="entry-content">
   <p> ...</p>
  </section>
  <footer class="entry-footer">
    <time>September 29, 2020</time>
  </footer>
  <a class="entry-link" href="https://xshi000.github.io/dbscan/"></a>
</article>
<article class="post-entry">
  <header class="entry-header">
    <h2>python进阶思维导图</h2>
  </header>
  <section class="entry-content">
   <p>1. 数据交换格式 2. 数据库编程 3. 网络编程 4. wxPython图形用户界面编程 5. 多线程编程 6. 网络爬虫 7. 数据可视化 8. 宠物商店项目 9. QQ聊天工具 ​...</p>
  </section>
  <footer class="entry-footer">
    <time>September 29, 2020</time>
  </footer>
  <a class="entry-link" href="https://xshi000.github.io/pymendpic/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="/">← Prev Page</a>
    <a class="next" href="/page/3/">Next Page →</a>
  </nav>
</footer></main>
<footer class="footer">
  <span>&copy; 2021 <a href="https://xshi000.github.io/">及时当勉励，岁月不待人！@iNuo</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://xshi000.github.io/highlight.min.js"></script>
<script>
  hljs.initHighlightingOnLoad();
</script>
</body>
</html>

